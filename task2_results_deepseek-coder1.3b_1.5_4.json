"Sure. Let's take time complexity as base for our ranking (in Big O notation): 
- Code1 has a higher upper bound than both lower bounds, it runs within O(n^2), because the inner loop iterates over 'i', and outer iteration through all indices less or equal to i in worst case scenario. This could be considered very efficient as we need at most one operation per element (with two nested loops).
- Code 2 is also pretty good, it runs within O(n) time complexity but has a lower bound because each sum calculation involves looking up and possibly calculating an array value that was not computed in the loop above. It's therefore more efficient than code1 when we have to do multiple operations on different parts of data (not only one fixed-sized subset).
  Second best is Code2 if you need calculate a large amount for all elements after initialisation or use memory allocation, as each individual calculation takes O(n) time. In any case the second worst code isn't ideal because it requires creating new array to store and then deletes (deallocates heap storage), so we get worse performance when data is not constant but changeable ie size of input would vary with 'i'.
- Code3 runs within O(n) time complexity, which means the most efficient code. It only iteratively sums elements in an array once without needing to do any further computations beyond its initialization phase (one pass), so it's very memory/CPU efficiency too and will always have better worst case scenario of running through all n steps than other codes ie., Code1, 2 & the best cases.
"